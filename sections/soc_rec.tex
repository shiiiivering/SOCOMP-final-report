\begin{CJK*}{GBK}{hei}
\zihao{5}
\vskip 1mm
\section{社交推荐}
\end{CJK*}

\begin{CJK*}{GBK}{song}

从万维网的诞生，到目前QQ、微信等社交软件，BiliBili、抖音等短视频平台，知乎、虎扑、豆瓣等社区交流平台的兴起，互联网百花齐放，人们的线上社交生活日益丰富。互联网的快速发展带来了丰富的信息，如何从繁杂的信息中获取有效的信息成为了当前线上用户的难题，造成了信息过载（Information Overload）的现象。与此同时，平台服务商如BiliBili、 知乎等为了用户的留存率和日活时长，淘宝、京东等电商平台为了促进用户消费，纷纷使用了推荐系统给用户推荐视频、商品等，这使得推荐系统变得十分重要。然而，虽然互联网的发展带来了十分丰富多元的信息，但是信息的稀疏性、冷启动问题、长尾效应等因素限制了推荐系统的性能。

传统的推荐系统将用户作为一个个独立的个体进行推荐，假设用户之间是独立同分布的。但是，用户之间存在着不同的社交联系，而用户的决策通常受到社交好友的影响，或者说拥有社交联系的用户有着相似的行为特征。这一假定可以由社会影响\cite{12}、同质性\cite{13}等研究解释。而这一假定结合推荐算法，就形成了社交推荐。

社交推荐方法基于传统的协同过滤推荐方法，加上了额外的社交信息，因此和传统方法一样，可以分为两大类别：基于内存的社交推荐和基于模型的社交推荐。

{\begin{CJK*}{GBK}{hei}\subsection{社交推荐的定义}\end{CJK*}}
在论文\cite{14}中，作者对社交推荐给出了两个定义。一个是狭窄的定义：将在线社交关系作为附加输入的任何推荐，即使用其他社交信号来增强现有推荐引擎。另一个宽泛的定义是：以社交媒体领域为目标的任何推荐系统。本文结合上述两个定义和近些年的相关研究，对社交推荐定义如下：考虑社交关系的任何推荐。相比论文\cite{14}中的狭窄定义，去除了在线关系，社交推荐中的社交关系虽然大部分来自于线上，但也有研究使用线下关系进行推荐，如对本科生的研究项目的推荐系统\cite{15}。相比宽泛的定义，去除了以社交媒体领域为目标的限定，这一限定较为宽泛，不好限制。

{\begin{CJK*}{GBK}{hei}\subsection{社交推荐与传统推荐的区别}\end{CJK*}}
相比于传统推荐方法，社交推荐使用了额外的社交信息来增强推荐的效果。假设用户之间的关系为$T\in \mathbb{R} ^{n\times n}$，当$T_{ij}=1$时表明用户i和用户j之间有联系，反之$T_{ij}=0$表明用户i和用户j之间没有联系。除此之外，还可以给社交关系网络的边加上权重。除了输入数据的不同，社交推荐还会使用社会网络分析的相关理论来提高推荐的性能，如社区发现、小世界理论等。

{\begin{CJK*}{GBK}{hei}\subsection{基于内存的社交推荐}\end{CJK*}}

基于内存的社交推荐使用的是基于内存的协同过滤算法，特别是面向用户的协同过滤算法。基于内存的协同过滤的基本思想是针对某一用户，使用N个相似的用户对该用户缺失的评分信息进行补全。而基于内存的社交推荐使用的N个相似用户不只来自于历史的评分信息，还包括用户之间的社交联系。

基于内存的社交推荐一般有两个步骤，第一是寻找N个相似的用户，第二步是聚合N个相似用户的信息对缺失信息进行预测。基于内存的社交推荐一般使用用户信任网络作为用户间的社交关系，用户信任网络如图2所示，其中节点是用户，边是信任值。在进行推荐时，通常需要先预测不相邻用户之间的信任值。

\begin{figure}[htbp]
\centerline{\includegraphics[width=3.15in]{graphs/Trust-network.png}}
图2\quad  用户信任网络\cite{18}。节点是用户，边是信任值。
\label{trust-net}
\end{figure}

\subsubsection{FilmTrust}

FilmTrust\cite{16} 是一个基于用户信任网络的推荐系统，预测的目标是用户对某部电影的评分。在这个系统中，用户之间的联系是用户之间的信任关系，用户会根据对好友的信任进行好友评分，评分越高或者说信任值越高，代表用户越信赖好友对电影的评分（所以会倾向于看好友看过的高分电影）。在这个信任网络中，用户只给好友评信任度，而对其他人是没有信任关系的，不是一个完全图，所以待预测用户和已经评分过的用户（评分者）之间可能不是邻居，没有连边，需要先计算他们之间的信任值。作者使用TidalTrust进行用户间信任值的计算。

TidalTrust\cite{17} 基于两点认识进行用户信任值的计算，第一点是使用更短的用户间路径能有更好的预测结果，第二点是使用信任值更高的路径有更好的预测结果。TidalTrust使用广度优先搜索寻找用户和评分者之间的路径，并找到最短路径，只取和最短路径长度一样的路径。从源节点开始，源节点会让邻居节点搜索到目标节点的路径，并使用以下公式计算到目标节点的信任值。

$$ t_{is}=\frac{\sum_{j\in adj(i)\ni t_{ij}>max}t_{ij}t_{js}}{\sum_{j\in adj(i)\ni t_{ij}>max}t_{ij}}.\eqno{\hbox{(11)}}$$

公式中adj(i)代表节点i的邻居节点，计算的值$t_{is}$是节点i到节点s的信任值，max是阈值，用于去除较低权重的边。

在得到了用户间的信任值之后，使用以下公式计算用户对某部电影的评分。

$$ r_{sm} = \frac{\sum_{i\in S} t_{si}r_{im}}{\sum_{i\in S} t_{si}}.\eqno{\hbox{(12)}} $$

公式计算的是用户s对某一电影m的评分，其中S是被挑选的评分者，$t_{si}$是用户s对用户i的信任值，$r_{im}$是用户i对m的评分。

\begin{figure*}[htbp]
\centerline{\includegraphics[width=6.5in]{graphs/trust-rs.png}}
图3\quad  信任感知推荐系统架构\cite{19}。
\label{trust-rs}
\end{figure*}

\subsubsection{MoleTrust}

MoleTrust\cite{18} 和TidalTrust\cite{17}类似，都是先根据已有的信任网络预测不相邻用户之间的信任值。MoleTrust 计算用户间信任值可以分为两步，第一步先去除网络中的循环，使得网络变成一个有向无环的DAG图。第二步是从源节点出发，逐渐计算每个被访问节点的信任值。

第一步的目的是破坏图中的循环，一个循环的例子如下：A信任B值为0.6，B信任C值为0.8，C信任A值为0.3。循环产生的问题是：在图游走过程中，需要多次访问同一个节点，逐步调整中间临时计算的信任值，直到该值收敛。如果只需每个节点访问一次，直接计算出最终的信任值，那么会使得时间复杂度与节点数量成线性关系。线性的时间复杂度是十分重要的，因为信任网络在实际应用中是一个很大的网络，复杂度太高难以使用。同时，第一步会对生成从源节点到其他节点的最短路径，其中大于阈值长度的路径将被去除，所以最终的网络是一个去除了部分边的有向无环图。

第二步是简单的图游走，从源节点开始，赋予初始的信任值为1。然后访问源节点的邻居节点（即深度为1的节点），计算邻居节点的信任值。然后再访问深度为2的节点，以此类推。所以所有节点只会被访问一次。在深度为k的所有节点的信任值的计算只依赖于深度为k-1的节点，而深度为k-1的节点的信任值是已经计算过的。新访问节点的信任值的计算如以下公式所示。

$$ trust(u) = \frac{\sum_{i\in predecessors}(trust(i)\times trust\_edge(i, u))}{\sum_{i\in predecessors}(trust(i))}.\eqno{\hbox{(13)}} $$

公式计算的是节点u的信任值，predecessors是第一步网络修改后u节点的前驱，trust\_edge(i, u)是网络的边权（用户i对u的信任值）。

\subsubsection{基于信任网络的社交推荐系统架构}

论文\cite{19}提出了信任网络感知的推荐系统架构，如图3所示。在图中，黑色框是基本模块，白色框是模块的输入输出。系统的输入是用户信任网络（trust matrix）和用户评分矩阵（ratings matrix）。系统的输出是用户对每个物体的预测评分矩阵（matrix of predicted ratings）。

和传统推荐系统不同的是，该系统多出了信任网络作为输入。和传统推荐系统相同的是，推荐分为两步，第一步先寻找用户的邻居，然后第二步使用邻居节点的信息预测用户的评分。最主要的不同点在于，该系统在计算相似度和加权平均时使用了额外的信任网络的信息。这也是基于内存的社交推荐的普遍特点。

\subsubsection{基于信任网络的社交推荐基本流程}

论文\cite{1} 介绍了基于信任网络的社交推荐基本流程和相关的方法。基于信任网络的社交推荐需要解决如何挑选用户的邻居节点和计算他们之间的相似度。

第一步是\textbf{构建信任网络}。信任网络可以表示为一个加权的有向图，节点代表用户，而边的权重代表用户间的信任值。用户间的信任值可以按以下公式计算：

$$ T_{uv} = \frac{d_{max} - d_{uv} + 1}{d_{max}}.\eqno{\hbox{(14)}} $$

其中$T_{uv}$代表用户u对v的信任值，$d_{max}$代表信任传播的最大距离，$d_{uv}$代表u和v之间的距离。由于在一些数据集中，用户之间没有明确的信任值，所以信任值可以依据以下公式计算：

$$ T_{uv} = \frac{\left | A_{uv} \right | }{\left | A_{u} \right |}.\eqno{\hbox{(15)}} $$

其中$A_{uv}$ 代表用户u和v共同评分的物体集合，而$A_{u}$代表用户u评分的物体集合。

第二步是\textbf{调整用户间的相似度计算}。由于用户-物体的评分矩阵通常是十分稀疏的，所以借助信任网络可以减少数据的稀疏性。为了调整用户间的相似度计算，用户间的权重$w_{uv}$可以如下调整\cite{20}：

$$
w_{uv} = \left\{\begin{matrix}
 \frac{2\times sim_{uv}\times T_{uv}}{sim_{uv} + T_{uv}}  & \quad sim_{uv} + T_{uv} \ne 0, and  \\
  & sim_{uv}\times T_{uv} \ne 0 \\
 sim_{uv} & sim_{uv} \ne 0,and\quad T_{uv} = 0 \\
 T_{uv} & sim_{uv} = 0,and\quad T_{uv} \ne 0\\
 0 & otherwise
\end{matrix}\right.\eqno{\hbox{(16)}}
$$

其中用户间的相似度$sim_{uv}$可以使用 Pearson 相关系数（PCC）计算。

第三步是\textbf{计算初始的评分值}，可以依据以下公式计算用户u的评分值$\hat{r}$\cite{20}：

$$
\hat{r} = \bar{r}_{u} + \frac{\sum_{v\in N_{u}}w_{uv}(r_{ui}-\bar{r}_{v})}{\sum_{v\in N_{u}}w_{uv}}.\eqno{\hbox{(17)}}
$$

其中$K_{ui}$是有对物体i进行评分的u的邻居。

第四步是\textbf{计算评分值的可靠性}。用户u对物体i的评分值$\hat{r}_{ui}$的可靠性$R_{ui}$计算如下\cite{20}：

$$
R_{ui}=(f_P(P_{ui})\cdot f_N(N_{ui})^{f_P(P_{ui})})^{\frac{1}{1+f_P(P_{ui})}}.\eqno{\hbox{(18)}}
$$

其中$P_{ui}$和$N_{ui}$反映的是对可靠值的正面和负面影响因子。$f_P$和$f_N$是相关的计算函数，具体计算如下：

$$
f_P(P_{ui}) = 1 - \frac{\bar{m}}{\bar{m}+P_{ui}}.\eqno{\hbox{(19)}}
$$

$$
f_N(N_{ui}) = （\frac{max-min-N_{ui}}{max-min})^{\gamma}.\eqno{\hbox{(20)}}
$$

$$
P_{ui}=\sum_{v\in K_{ui}} w_{uv}.\eqno{\hbox{(21)}}
$$

$$
N_{ui}=\frac{\sum_{v\in K_{ui}} w_{uv}(r_{vi}-\bar{r}_v-\hat{r}_{ui}+\bar{r}_u)^2}{\sum_{v\in K_{ui}} w_{uv}}.\eqno{\hbox{(22)}}
$$

$$
\gamma = \frac{ln0.5}{ln\frac{max-min+\bar{v}}{max-min}}.\eqno{\hbox{(23)}}
$$

具体来说，当正面因子$f_P(P_{ui})$越大，负面因子$f_N(N_{ui})$越小，可靠性越高。

第五步是\textbf{重建信任网络}，按照第四步的方法进行评分值可靠性的评估，如果低于某一阈值，那么就需要重新对用户进行信任网络的构建。

第六步是\textbf{预测最终的评分结果并进行推荐}。按照第二步的方法进行最终评分结果的预测，然后可以依据Top-N的评分给用户进行推荐。

{\begin{CJK*}{GBK}{hei}\subsection{基于模型的社交推荐}\end{CJK*}}

推荐系统研究的是两个对象（人与物）以及两者之间联系的学科。更具体地说，就是需要科学的建模用户画像、物品画像，以及如何设计高效的匹配算法（函数）来为特定的用户挑选出合适的物品，因此也可以形象的理解为“两点一线”，“两点”即为用户和物品，“一线”为连接用户和物品之间关系的函数。传统的推荐系统不得不从骨感的用户-物品交互数据中学到这“两点一线“，因此在学习的过程中不得不面临数据稀疏和冷启动的问题。

社交网络分析研究的是人与人之间相互作用、相互连接以及相互影响的理论。作为传统并骨感的数据的有效补充，社交网络可以丰富从骨感数据中学到的用户画像，以及增强用户与物品之间关系的函数，从侧面丰富了”两点一线“。因此结合社交网络的推荐可以理解为通过利用社交网络分析技术来更好的理解人与人之间的行为、关系等机理以此来更好的为合适的人找到合适的物品。

基于模型的方法采用数据挖掘和机器学习算法对评分数据样本进行训练学习并建立模型，现有模型大致可以从以下四个方面进行讨论：同质性和社会影响、小世界理论、无标度网络以及强弱关系。

\subsubsection{同质性和社会影响}
大多数前期的社会化推荐论文都是基于此理论（同质性和社会影响，Homophily and Social Influence），相互连接的用户更趋向于有相似的行为偏好，同时行为偏好相似的人更倾向于建立连接。反映在推荐模型中的含义即为约束用户的特征向量应该尽可能的与其朋友的特征向量在向量空间当中距离相近。

1）SocialFM算法

SocialFM算法是将信任传播纳入社交网络推荐的矩阵分解模型的方法：
由于社交影响，用户$u$ 的行为会受到其直接邻居节点$N_{u}$的影响。即用户$u$ 的特征向量取决于他的直接邻居的特征，记为：$$\hat{U_{u}}=\frac{\sum_{v\in{N_{u}}}T_{u,v}U_{v}}{\sum_{v\in{N_{u}T_{u,v}}}}=\frac{\sum_{v\in{N_{u}}}T_{u,v}U_{v}}{|N_{u}|}.\eqno{\hbox{(24)}}$$
$\hat{U_{u}}$是用户$u$在给定其直接邻居节点下的特征向量,这里使用的社交网络为二值网络，即$T_{u,v}$的值为0或1。 且有 $$\hat{U_{u}}=\sum_{v\in{N_{u}}}T_{u,v}U_{v}.\eqno{\hbox{(25)}}$$由上式可知，一个用户的潜在特征向量的估计是其直接邻居的潜在特征向量的加权平均值.将社交网络考虑在内并不会改变观察评分的条件分布方程。它只影响用户潜在的特征向量。
SocialFM算法目的在于约束用户的行为特征应该与与用户所连接的社交邻居的平均偏好尽可能的相近，具体函数如下所示：
\begin{displaymath}
\begin{split}
L_{SocialFM}=\frac{1}{2}\sum_{(u,i)\in{\Omega}}(r_{ui}-p_{u}^{T}q_{i})^2\\
+\alpha(P-{u}-\sum_{v\in{F_{u}}}S_{uv}p_{v})^2\\
+\frac{\lambda}{2}(||p_{u}||^2+||q_{i}||^2)
\end{split}
\end{displaymath}
其中，该函数具体包含三个部分，第一部分为基本的矩阵分解模型，目的在于学习用户的评分偏好；第二部分为社交约束项，目的在于对用户向量进行约束，使得该用户的特征向量与朋友的社交向量的平均尽可能的相近；第三部分为正则项，用来缓解模型的过拟合问题。
SocialFM模型通过对信任传播进行建模，就算用户没有评分数据，只要他拥有社交关系，就可以学习得到他的特征向量。因此，该模型能够显著提高冷启动用户的推荐准确性。

2）SoReg算法

SoReg算法基于用户所关注的好友的爱好存在多样性的假设，即认为信任关系和好友关系在许多方面是不同的，信任生成过程是一个不需要用户确认关系的单方面行为，只需依靠用户之间具有相似的偏好即可，而好友关系则是现实世界中的合作和相互关系，比如同学、同事等。针对不同类型的社交关系，SoReg提出了基于平均值和基于个体的两种正则化方法。由于基于平均值的正则化方法对那些好友有不同偏好的用户不敏感，这会造成信息丢失，导致用户特征向量建模不准确，所以这里重点介绍基于个体的正则化方法。该方法认为应该对不同关系强度的好友加以区分，这样可以有
效限制用户偏好与其不同好友偏好间的差异。不再强制要求用户必须与全体朋友的偏好一致，而是约束用户与各自的好友存在不同的社交影响，具体的函数如下所示：
\begin{displaymath}
\begin{split}
L_{SoReg}=\frac{1}{2}\sum_{(u,i)\in{\Omega}}(r_{ui}-p_{u}^{T}q_{i})^2\\
+\alpha\sum_{v\in{F_{u}}}S_{uv}(p_{u}-p_{v})^2\\
+\frac{\lambda}{2}(||p_{u}||^2+||q_{i}||^2)
\end{split}
\end{displaymath}
其中，第一和第三部分与SocialMF方法一致，不同的是第二部分社交约束项。由之前的约束用户的向量与关注朋友向量的平均向量相近改进为约束用户的向量与每一个关注朋友的向量相近，同时考虑了用户与每个朋友之间的社交相似性，相似性度量为两个用户的共同打分程度。通过改进，使得算法不仅仅考虑用户的社交连接，还将评分偏好纳入到了社交相似性度量上，起到了细粒度的社交影响对于推荐的提升。

3）SoRec算法

SocialFM算法和SoRec算法都可以看作是在矩阵分解的基础模型上，通过增加社交约束项来学习用户的向量表示。除了上述方式来融合社交信息外，还可以通过同享表示的方式来利用社交信息。HaoMa等人提出的SoRec 算法可以看作基于特征共享的社交推荐算法，具体的公式如下所示。
\begin{displaymath}
\begin{split}
L_{SoRec}=\frac{1}{2}\sum_{(u,i)\in{\Omega}}(r_{ui}-p_{u}^{T}q_{i})^2\\
+\alpha\sum_{v\in{F_{u}}}(S_{uv}-p_{u}^{T}z_{v})^2\\
+\frac{\lambda}{2}(||p_{u}||^2+||q_{i}||^2+||z_{v}||^2)
\end{split}
\end{displaymath}
其中，用户低维特征向量通过同时分解评分矩阵和社交关系矩阵来进行学习，使得学到的用户特征向量可以兼顾用户的评分习惯和社交特性。

SoRec方法通过分解用户间的社交关系矩阵从而对用户存在的潜在特征进行学习，同时通过共享用户特征矩阵进而能够达到使用朋友的偏好信息进行推荐的目的，有效解决了数据稀疏性和预测精度差的问题，复杂性分析表明该方法可以适用于较大的数据集，特别是在用户拥有较少或没有评分的情况下；但该方法存在的不足之处就是它把社交关系矩阵分解成用户特征矩阵与社交特征矩阵缺乏自然规律解释，不能反映真实世界的推荐过程。

4）TrustSVD算法

TrustSVD模型是两一种共享表示学习的方法，不仅建模了用户的显示评分数据与社交关系，还考虑了用户的隐式行为数据以及社交关系。在SVD++模型的基础上引入了隐式社交信息，具体公式如下：
\begin{displaymath}
\begin{split}
L_{TrustSVD}=\frac{1}{2}\sum_{(u,i)\in{\Omega}}(r_{ui}-\hat{r_{ui}})^2\\
+\frac{\alpha}{2}(b_{u}^2+b_{i}^2+||p_{u}||^2+||q_{i}||^2+||y_{i}||^2)
\end{split}
\end{displaymath}
其中，第一项为评分矩阵分解，旨在拟合用户的评分习惯同时学得隐式行为信息；第二项为信任矩阵分解，旨在拟合用户的信任关系；第三项为正则项，用来避免模型出现过拟合问题。为了同时捕捉用户的显式和隐式的评分以及社交信息，关键在于第一项，其中用户对于项目的具体评分预测公式如下所示:
\begin{displaymath}
\begin{split}
\hat{r_{ui}}=\mu+b_{u}+b_{i}+q_{i}^{T}(P_{u}+|I_{u}|^{-\frac{1}{2}}\sum_{i\in{I_{u}}}y_{i}\\
+|F_{u}|^{-\frac{1}{2}}\sum_{v\in{F_{u}}z_{v}})
\end{split}
\end{displaymath}
通过将用户的隐式反馈信息以及用户的隐式社交信息考虑到模型中，使得用户的特征表示不仅仅依靠用户评分特征向量，还依靠用户的隐式反馈信息以及用户的隐式朋友信息，致使用户的特征表示更符合实际应用场景。

\subsubsection{小世界理论}

小世界理论，又名六度分隔理论（Six Degrees of Separation），也就是任何两个陌生人之间所间隔的人不会超过五个，也就是说，最多通过五个人你就能够认识世界上任何一个陌生人。Jamali等人提出了TrustWalker算法，一个结合了基于信任方法和协同过滤方法的随机游走模型。其中，在随机游走的过程中应用了六度分隔理论。通过用户所连接的社交网络进行随机询问，询问的深度不超过六度分隔理论中的理论数值。另外，不仅只考虑特定用户的目标项目评分，还把目标项目的相似项目考虑其中（基于项目的协同过滤思想）。随着随机游走轮数的增加，使用相似项目评分的概率也逐渐增加。

在进行随机游走之前先得建立用户之间的信任关系图，如果没有显式的社交关系，我们就根据人口统计学相关的知识（比如性别、年龄、种族、地区、教育经历等）计算用户之间的相似度，相似度很高的认为他们之间有信任关系。目标是估计用户$u_{0}$对荐$i$的评分。

用户$u_{0}$随机游走，在信任网络上前进了$k$步后到达用户$u$。如果$u$已经评价过项目$i$，则停止此次游走，返回$r_{ui}$作为此次游走的结果。如果$u$未评价过$i$,则有以下2个选择：

(1)以概率$P_{u,i,k}$停在用户$u$，选择$u$评价过的与$i$最相似的$m$个项目的评分，根据下式计算$P_{ui}$作为返回结果：
$$P_{ui}=\frac{\sum_{item j which similar to i}Y Sim(i,j)\times{r_{uj}}}{\sum_{item j which similar to i}Y Sim(i,j)}$$
其中$Y Sim(i,j)$是项目$i$和$j$的云相似度。

(2)以概率$1-\phi_{u,i,k}$继续游走，从当前用户$u$信任的邻居中随机选择一个直接邻居$v$。

参数$\phi_{u,i,k}$并非固定不变，它是停留在用户$u$的概率，这与$u$评价过的项目与目标项目$i$ 的相似度有关，我们可以简单的认为$u$评价过的项目中与项目$i$最相似的那个相似度越大，$\phi_{u,i,k}$就应该越大。此外在信任网络中游走得越深则噪声越大，$\phi_{u,i,k}$就应该越大。
$$\phi=max_{j\in{RI_{u}}}\frac{YSim(i,j)}{1+e^{-\frac{k}{2}}}$$
其中$RI_{u}$是用户$u$评价过的项目集合。每次游走遇到以下3种情况就停止：
(1)遇到一个评价过项目$i$的用户$u$;
(2)决定停止于某个用户$u$，将与$i$最相似的$m$个项目的聚合评分作为随机游走的结果返回。
(3)随机游走可能面临永远不会停止的情况，为避免这种情况，引入“小世界理论”，即”六度空间“的概念，设定随机游走步数$k$的最大值为6。


1）无标度网络

现实世界中的网络，只有少数的节点往往拥有大量的连接，而大部分节点却存在很少连接。一般将网络中的节点度分布符合幂律分布的复杂网络称为无标度网络（Scale-free Network）。这也很符合实际情况，大佬往往是极少的，更多的是平凡普通人。

网络嵌入（Network Embedding）技术Deepwalk，node2vec等模型之所以有效，是因为在社交网络中随机游走产生的序列通过统计结点的分布发现，用户结点的分布与词的分布都满足幂律分布（Power Law）。因此很巧妙的将自然语言处理中的词嵌入技术迁移到社交网络分析中的结点嵌入任务中。可以很自然的将随机游走序列（Sequence）类比为自然语言中的句子（Sentence），社交网络中的用户结点（Node）类比为语料库中的词语（Word），然后将其输入到word2vec模型中，以此产生低维、连续、稠密的用户结点的嵌入表示。其中，将Embedding技术应用于社会化推荐场景中的方法之一为CUNE，其具体的算法公式与SoReg类似，都是基于社交正则项来约束基本的矩阵分解模型，详细的公式表示如下：
\begin{displaymath}
\begin{split}
\Phi\equiv\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^nI_{ij}(r_{ij}-z_{i}^{T}q_{j})^2+\frac{\lambda}{2}(||Z||_{F}^2+||Q||_{F}^2)\\
+\frac{\alpha}{2}\sum_{i=1}^m\sum_{f\in{H(i)}}||z_{i}-z_{f}||_{F}^2
\end{split}
\end{displaymath}

2）强弱关系

社交网络中的连接关系并不是完全一样的，存在强弱关系（Strong and Weak ties）一说。关于人际关系强弱的解释，弱连接表示拥有频繁交互的亲密朋友，而弱连接表示存在连接但交互行为极少的熟人。

基于社交网络中的强弱联系的理论，Xin等人提出了TBPR模型。该模型在BPR的基础上细分了对于物品的排序分类，由原来的“用户产生行为的项目集合>用户未产生行为的项目集合”扩充为“用户产生行为的项目集合>强弱连接用户同时产生过行为的项目集合>只有强连接用户产生行为的项目集合>只有所连接用户产生行为的项目集合>用户未产生行为的项目集合”。相应的函数表示为：
\begin{displaymath}
\begin{split}
J(\Theta)=\ln{L(\Theta)}-r(\Theta)\\
=\sum_{u\in{U}}(\sum_{i\in{C_{u}^{self}}}\sum_{j\in{C_{u}^{joint}}}\ln{\delta(\hat{x_{ui}}-\hat{x_{uj}})}\\
+\sum_{j\in{C_{u}^{joint}}}\sum_{w\in{C_{u}^{week}}}\ln{\delta(\hat{x_{uj}}-\hat{x_{uw}})}\\
+\sum_{w\in{C_{u}^{week}}}\sum_{s\in{C_{u}^{strong}}}\ln{\delta(\frac{\hat{x_{uw}}-\hat{x_{us}}}{1+1/g(\theta_{g})})}\\
+\sum_{s\in{C_{u}^{strong}}}\sum_{k\in{C_{u}^{none}}}\ln{\delta(\hat{x_{us}}-\hat{x_{uk}})})\\
-\lambda_{p}\sum_{u\in{U}}||P_{u}||_{2}^2-\lambda_{q}\sum_{i\in{I}}||Q_{u}||_{2}^2-\lambda_{\theta}\theta_{g}^2
\end{split}
\end{displaymath}
\end{CJK*}
