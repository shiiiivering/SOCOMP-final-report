\begin{CJK*}{GBK}{hei}
\zihao{5}
\vskip 1mm
\section{社交推荐}
\end{CJK*}

\begin{CJK*}{GBK}{song}

从万维网的诞生，到目前QQ、微信等社交软件，BiliBili、抖音等短视频平台，知乎、虎扑、豆瓣等社区交流平台的兴起，互联网百花齐放，人们的线上社交生活日益丰富。互联网的快速发展带来了丰富的信息，如何从繁杂的信息中获取有效的信息成为了当前线上用户的难题，造成了信息过载（Information Overload）的现象。与此同时，平台服务商如BiliBili、 知乎等为了用户的留存率和日活时长，淘宝、京东等电商平台为了促进用户消费，纷纷使用了推荐系统给用户推荐视频、商品等，这使得推荐系统变得十分重要。然而，虽然互联网的发展带来了十分丰富多元的信息，但是信息的稀疏性、冷启动问题、长尾效应等因素限制了推荐系统的性能。

传统的推荐系统将用户作为一个个独立的个体进行推荐，假设用户之间是独立同分布的。但是，用户之间存在着不同的社交联系，而用户的决策通常受到社交好友的影响，或者说拥有社交联系的用户有着相似的行为特征。这一假定可以由社会影响\cite{2}、同质性\cite{3}等研究解释。而这一假定结合推荐算法，就形成了社交推荐。

{\begin{CJK*}{GBK}{hei}\subsection{社交推荐的定义}\end{CJK*}}
在论文\cite{4}中，作者对社交推荐给出了两个定义。一个是狭窄的定义：将在线社交关系作为附加输入的任何推荐，即使用其他社交信号来增强现有推荐引擎。另一个宽泛的定义是：以社交媒体领域为目标的任何推荐系统。本文结合上述两个定义和近些年的相关研究，对社交推荐定义如下：考虑社交关系的任何推荐。相比论文\cite{4}中的狭窄定义，去除了在线关系，社交推荐中的社交关系虽然大部分来自于线上，但也有研究使用线下关系进行推荐，如对本科生的研究项目的推荐系统\cite{5}。相比宽泛的定义，去除了以社交媒体领域为目标的限定，这一限定较为宽泛，不好限制。

{\begin{CJK*}{GBK}{hei}\subsection{社交推荐与传统推荐的区别}\end{CJK*}}
相比于传统推荐方法，社交推荐使用了额外的社交信息来增强推荐的效果。假设用户之间的关系为$T\in \mathbb{R} ^{n\times n}$，当$T_{ij}=1$时表明用户i和用户j之间有联系，反之$T_{ij}=0$表明用户i和用户j之间没有联系。除此之外，还可以给社交关系网络的边加上权重。除了输入数据的不同，社交推荐还会使用社会网络分析的相关理论来提高推荐的性能，如社区发现、小世界理论等。


{\begin{CJK*}{GBK}{hei}\subsection{社交推荐系统}\end{CJK*}}
社交推荐方法基于传统的协同过滤推荐方法，加上了额外的社交信息，因此和传统方法一样，可以分为两大类别：基于内存的社交推荐和基于模型的社交推荐。


\subsubsection{基于内存的社交推荐}
基于内存的社交推荐使用的是基于内存的协同过滤算法，特别是面向用户的协同过滤算法。基于内存的协同过滤的基本思想是针对某一用户，使用N个相似的用户对该用户缺失的评分信息进行补全。而基于内存的社交推荐使用的N个相似用户不只来自于历史的评分信息，还包括用户之间的社交联系。

基于内存的社交推荐一般有两个步骤，第一是寻找N个相似的用户，第二步是聚合N个相似用户的信息对缺失信息进行预测。基于内存的社交推荐一般使用用户信任网络作为用户间的社交关系，用户信任网络如图1所示，其中节点是用户，边是信任值。在进行推荐时，通常需要先预测不相邻用户之间的信任值。

\begin{figure}[htbp]
\centerline{\includegraphics[width=3.15in]{graphs/Trust-network.png}}
图1\quad  用户信任网络\cite{8}。节点是用户，边是信任值。
\label{trust-net}
\end{figure}

\noindent (1) FilmTrust

FilmTrust\cite{6} 是一个基于用户信任网络的推荐系统，预测的目标是用户对某部电影的评分。在这个系统中，用户之间的联系是用户之间的信任关系，用户会根据对好友的信任进行好友评分，评分越高或者说信任值越高，代表用户越信赖好友对电影的评分（所以会倾向于看好友看过的高分电影）。在这个信任网络中，用户只给好友评信任度，而对其他人是没有信任关系的，不是一个完全图，所以待预测用户和已经评分过的用户（评分者）之间可能不是邻居，没有连边，需要先计算他们之间的信任值。作者使用TidalTrust进行用户间信任值的计算。

TidalTrust\cite{7} 基于两点认识进行用户信任值的计算，第一点是使用更短的用户间路径能有更好的预测结果，第二点是使用信任值更高的路径有更好的预测结果。TidalTrust使用广度优先搜索寻找用户和评分者之间的路径，并找到最短路径，只取和最短路径长度一样的路径。从源节点开始，源节点会让邻居节点搜索到目标节点的路径，并使用以下公式计算到目标节点的信任值。

$$ t_{is}=\frac{\sum_{j\in adj(i)\ni t_{ij}>max}t_{ij}t_{js}}{\sum_{j\in adj(i)\ni t_{ij}>max}t_{ij}} $$

公式中adj(i)代表节点i的邻居节点，计算的值$t_{is}$是节点i到节点s的信任值，max是阈值，用于去除较低权重的边。

在得到了用户间的信任值之后，使用以下公式计算用户对某部电影的评分。

$$ r_{sm} = \frac{\sum_{i\in S} t_{si}r_{im}}{\sum_{i\in S} t_{si}} $$

公式计算的是用户s对某一电影m的评分，其中S是被挑选的评分者，$t_{si}$是用户s对用户i的信任值，$r_{im}$是用户i对m的评分。

\begin{figure*}[htbp]
\centerline{\includegraphics[width=6.5in]{graphs/trust-rs.png}}
图2\quad  信任感知推荐系统架构\cite{9}。
\label{trust-rs}
\end{figure*}

\noindent (2) MoleTrust

MoleTrust\cite{8} 和TidalTrust\cite{7}类似，都是先根据已有的信任网络预测不相邻用户之间的信任值。MoleTrust 计算用户间信任值可以分为两步，第一步先去除网络中的循环，使得网络变成一个有向无环的DAG图。第二步是从源节点出发，逐渐计算每个被访问节点的信任值。

第一步的目的是破坏图中的循环，一个循环的例子如下：A信任B值为0.6，B信任C值为0.8，C信任A值为0.3。循环产生的问题是：在图游走过程中，需要多次访问同一个节点，逐步调整中间临时计算的信任值，直到该值收敛。如果只需每个节点访问一次，直接计算出最终的信任值，那么会使得时间复杂度与节点数量成线性关系。线性的时间复杂度是十分重要的，因为信任网络在实际应用中是一个很大的网络，复杂度太高难以使用。同时，第一步会对生成从源节点到其他节点的最短路径，其中大于阈值长度的路径将被去除，所以最终的网络是一个去除了部分边的有向无环图。

第二步是简单的图游走，从源节点开始，赋予初始的信任值为1。然后访问源节点的邻居节点（即深度为1的节点），计算邻居节点的信任值。然后再访问深度为2的节点，以此类推。所以所有节点只会被访问一次。在深度为k的所有节点的信任值的计算只依赖于深度为k-1的节点，而深度为k-1的节点的信任值是已经计算过的。新访问节点的信任值的计算如以下公式所示。

$$ trust(u) = \frac{\sum_{i\in predecessors}(trust(i)\times trust\_edge(i, u))}{\sum_{i\in predecessors}(trust(i))} $$

公式计算的是节点u的信任值，predecessors是第一步网络修改后u节点的前驱，trust\_edge(i, u)是网络的边权（用户i对u的信任值）。

\noindent (3) 基于信任网络的社交推荐系统架构

论文\cite{9}提出了信任网络感知的推荐系统架构，如图2所示。在图中，黑色框是基本模块，白色框是模块的输入输出。系统的输入是用户信任网络（trust matrix）和用户评分矩阵（ratings matrix）。系统的输出是用户对每个物体的预测评分矩阵（matrix of predicted ratings）。

和传统推荐系统不同的是，该系统多出了信任网络作为输入。和传统推荐系统相同的是，推荐分为两步，第一步先寻找用户的邻居，然后第二步使用邻居节点的信息预测用户的评分。最主要的不同点在于，该系统在计算相似度和加权平均时使用了额外的信任网络的信息。这也是基于内存的社交推荐的普遍特点。

\noindent (4) 基于信任网络的社交推荐基本流程

论文\cite{10} 介绍了基于信任网络的社交推荐基本流程和相关的方法。基于信任网络的社交推荐需要解决如何挑选用户的邻居节点和计算他们之间的相似度。

第一步是\textbf{构建信任网络}。信任网络可以表示为一个加权的有向图，节点代表用户，而边的权重代表用户间的信任值。用户间的信任值可以按以下公式计算：

$$ T_{uv} = \frac{d_{max} - d_{uv} + 1}{d_{max}} $$

其中$T_{uv}$代表用户u对v的信任值，$d_{max}$代表信任传播的最大距离，$d_{uv}$代表u和v之间的距离。由于在一些数据集中，用户之间没有明确的信任值，所以信任值可以依据以下公式计算：

$$ T_{uv} = \frac{\left | A_{uv} \right | }{\left | A_{u} \right |} $$

其中$A_{uv}$ 代表用户u和v共同评分的物体集合，而$A_{u}$代表用户u评分的物体集合。

第二步是\textbf{调整用户间的相似度计算}。由于用户-物体的评分矩阵通常是十分稀疏的，所以借助信任网络可以减少数据的稀疏性。为了调整用户间的相似度计算，用户间的权重$w_{uv}$可以如下调整\cite{11}：

$$
w_{uv} = \left\{\begin{matrix}
 \frac{2\times sim_{uv}\times T_{uv}}{sim_{uv} + T_{uv}}  & \quad sim_{uv} + T_{uv} \ne 0, and  \\
  & sim_{uv}\times T_{uv} \ne 0 \\
 sim_{uv} & sim_{uv} \ne 0,and\quad T_{uv} = 0 \\
 T_{uv} & sim_{uv} = 0,and\quad T_{uv} \ne 0\\
 0 & otherwise
\end{matrix}\right.
$$

其中用户间的相似度$sim_{uv}$可以使用 Pearson 相关系数（PCC）计算。

第三步是\textbf{计算初始的评分值}，可以依据以下公式计算用户u的评分值$\hat{r}$\cite{11}：

$$
\hat{r} = \bar{r}_{u} + \frac{\sum_{v\in N_{u}}w_{uv}(r_{ui}-\bar{r}_{v})}{\sum_{v\in N_{u}}w_{uv}} 
$$

其中$K_{ui}$是有对物体i进行评分的u的邻居。

第四步是\textbf{计算评分值的可靠性}。用户u对物体i的评分值$\hat{r}_{ui}$的可靠性$R_{ui}$计算如下\cite{11}：

$$
R_{ui}=(f_P(P_{ui})\cdot f_N(N_{ui})^{f_P(P_{ui})})^{\frac{1}{1+f_P(P_{ui})}}
$$

其中$P_{ui}$和$N_{ui}$反映的是对可靠值的正面和负面影响因子。$f_P$和$f_N$是相关的计算函数，具体计算如下：

$$
f_P(P_{ui}) = 1 - \frac{\bar{m}}{\bar{m}+P_{ui}} 
$$

$$
f_N(N_{ui}) = （\frac{max-min-N_{ui}}{max-min})^{\gamma} 
$$

$$
P_{ui}=\sum_{v\in K_{ui}} w_{uv}
$$

$$
N_{ui}=\frac{\sum_{v\in K_{ui}} w_{uv}(r_{vi}-\bar{r}_v-\hat{r}_{ui}+\bar{r}_u)^2}{\sum_{v\in K_{ui}} w_{uv}}
$$

$$
\gamma = \frac{ln0.5}{ln\frac{max-min+\bar{v}}{max-min}} 
$$

具体来说，当正面因子$f_P(P_{ui})$越大，负面因子$f_N(N_{ui})$越小，可靠性越高。

第五步是\textbf{重建信任网络}，按照第四步的方法进行评分值可靠性的评估，如果低于某一阈值，那么就需要重新对用户进行信任网络的构建。

第六步是\textbf{预测最终的评分结果并进行推荐}。按照第二步的方法进行最终评分结果的预测，然后可以依据Top-N的评分给用户进行推荐。

\end{CJK*}
